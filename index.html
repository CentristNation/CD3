        // Test function to verify buffer functionality
        function testBufferTool() {
            console.log('üß™ Testing buffer tool...');
            const bufferBtn = document.getElementById('bufferBtn');
            const bufferControls = document.getElementById('bufferControls');
            
            if (bufferBtn) {
                console.log('‚úÖ Buffer button found, testing click...');
                // Force show buffer controls for testing
                if (bufferControls) {
                    bufferControls.style.display = 'flex';
                    console.log('‚úÖ Buffer controls forced visible');
                }
                
                // Test the toggle function
                console.log('Current buffer mode:', isBufferMode);
                toggleBufferMode();
                console.log('Buffer mode after toggle:', isBufferMode);
            } else {
                console.error('‚ùå Buffer button not found for testing');
            }
        }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proposed CD 3 Data Analytics</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #007bff;
        }
        
        .main-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 0;
            line-height: 1.3;
        }
        
        .subtitle {
            font-size: 13px;
            color: #666;
            margin: 3px 0 0 0;
        }
        
        .status-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            font-size: 13px;
            border-left: 4px solid #007bff;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.8);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }
        
        .selection-tools {
            text-align: center;
        }
        
        .tool-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .tool-button:hover {
            background: #0056b3;
        }
        
        .tool-button.active {
            background: #28a745;
        }
        
        .filter-item {
            margin-bottom: 12px;
        }
        
        .filter-label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .party-icon {
            width: 20px;
            height: 20px;
            margin-right: 6px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dem-icon { color: #0066cc; }
        .rep-icon { color: #cc0000; }
        
        .filter-slider {
            width: 100%;
            margin: 3px 0;
        }
        
        .filter-value {
            font-size: 11px;
            color: #666;
            text-align: center;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }
        
        .summary-label {
            font-weight: 500;
            color: #555;
        }
        
        .summary-value {
            font-weight: bold;
            color: #333;
        }
        
        .legend {
            position: absolute;
            bottom: 60px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 12px;
        }
        
        .legend h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 13px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }
        
        .legend-color {
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #ccc;
        }
        
        .credit {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 11px;
            color: #666;
            z-index: 1000;
        }
        
        .mode-info {
            font-size: 10px;
            margin-top: 5px;
            color: #666;
            text-align: center;
        }
        
        .county-filter {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 8px;
            background: white;
        }
        
        .county-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
            font-size: 11px;
        }
        
        .county-checkbox {
            margin-right: 6px;
        }
        
        .county-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .county-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .county-btn:hover {
            background: #5a6268;
        }
        
        .buffer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .buffer-input {
            flex: 1;
        }
        
        .buffer-value {
            font-size: 11px;
            color: #666;
            min-width: 60px;
        }
        
        .buffer-active {
            background: #28a745 !important;
            color: white !important;
        }
        
        .buffer-active:hover {
            background: #218838 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1 class="main-title">Proposed CD 3 Data Analytics</h1>
                <p class="subtitle">By Ifte Islam PhD</p>
            </div>
            
            <div class="status-message" id="statusMessage">
                üîÑ Loading data...
            </div>
            
            <div class="section" id="selectionSection">
                <div class="section-title">üéØ Selection Tools</div>
                <div class="selection-tools">
                    <button class="tool-button" id="bufferBtn" onclick="toggleBufferMode()">üìç Buffer Select</button>
                    <button class="tool-button" id="clearSelection" onclick="clearAllSelections()">üóëÔ∏è Clear All</button>
                    <div class="mode-info" id="modeInfo">Use drawing tools in top-right corner of map</div>
                    <div class="buffer-controls" id="bufferControls" style="display: none;">
                        <input type="range" class="buffer-input" id="bufferRange" min="1" max="50" value="10">
                        <div class="buffer-value" id="bufferValue">10 miles</div>
                    </div>
                </div>
            </div>
            
            <div class="section" id="countySection">
                <div class="section-title">üèõÔ∏è County Filter</div>
                <div class="county-controls">
                    <button class="county-btn" onclick="selectAllCounties()">All</button>
                    <button class="county-btn" onclick="selectNoCounties()">None</button>
                </div>
                <div class="county-filter" id="countyFilter">
                    <div style="text-align: center; color: #666; font-size: 11px;">Loading counties...</div>
                </div>
            </div>
            
            <div class="section" id="filterSection">
                <div class="section-title">üéØ Filters (Min %)</div>
                
                <div class="filter-item">
                    <div class="filter-label">
                        <div class="party-icon dem-icon">üê¥</div>
                        Democratic %
                    </div>
                    <input type="range" class="filter-slider" id="demSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="demValue">Show areas ‚â• 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">
                        <div class="party-icon rep-icon">üêò</div>
                        Republican %
                    </div>
                    <input type="range" class="filter-slider" id="repSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="repValue">Show areas ‚â• 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">White %</div>
                    <input type="range" class="filter-slider" id="whiteSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="whiteValue">Show areas ‚â• 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Black %</div>
                    <input type="range" class="filter-slider" id="blackSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="blackValue">Show areas ‚â• 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Hispanic %</div>
                    <input type="range" class="filter-slider" id="hispanicSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="hispanicValue">Show areas ‚â• 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Asian %</div>
                    <input type="range" class="filter-slider" id="asianSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="asianValue">Show areas ‚â• 0%</div>
                </div>
            </div>
            
            <div class="section" id="summarySection">
                <div class="section-title">üìä Selected Area Summary</div>
                <div id="summaryContent">
                    <p style="color: #666; text-align: center; font-size: 12px;">Select areas to view data</p>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="legend" id="legend">
                <h4>Democratic %</h4>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #8b0000;"></div>
                    <span>0-20%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc143c;"></div>
                    <span>20-40%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <span>40-49%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4dabf7;"></div>
                    <span>50-60%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #1864ab;"></div>
                    <span>60%+</span>
                </div>
            </div>
            <div class="credit">PrecinctSmart.com</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.min.js"></script>
    <script>
        let map, geoJsonLayer, selectedFeatures = [];
        let originalData = null;
        let drawnItems = null;
        let isBufferMode = false;
        let selectedCounties = new Set();
        let bufferRadius = 10; // miles

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Starting application...');
            
            // Debug: Check if buffer elements exist
            setTimeout(() => {
                const bufferBtn = document.getElementById('bufferBtn');
                const bufferControls = document.getElementById('bufferControls');
                const bufferRange = document.getElementById('bufferRange');
                
                console.log('üîç Buffer elements check:');
                console.log('- Buffer button:', bufferBtn ? '‚úÖ Found' : '‚ùå Missing');
                console.log('- Buffer controls:', bufferControls ? '‚úÖ Found' : '‚ùå Missing');
                console.log('- Buffer range:', bufferRange ? '‚úÖ Found' : '‚ùå Missing');
                
                if (bufferBtn) {
                    console.log('‚úÖ Buffer tool should be visible in sidebar');
                    // Make sure it's visible
                    bufferBtn.style.display = 'inline-block';
                    bufferBtn.style.visibility = 'visible';
                } else {
                    console.error('‚ùå Buffer button not found in DOM');
                }
                
                if (bufferControls) {
                    bufferControls.style.visibility = 'visible';
                }
            }, 1000);
            
            // Force show interface immediately
            setTimeout(() => {
                updateStatus('üîÑ Initializing map and interface...');
            }, 100);
            
            // Initialize map after a short delay to ensure DOM is ready
            setTimeout(() => {
                initMap();
            }, 300);
            
            // Force load dummy data as backup after 3 seconds if nothing else worked
            setTimeout(() => {
                if (!originalData) {
                    console.log('üîß Emergency fallback: forcing dummy data load');
                    updateStatus('üîß Fallback: Loading test data...');
                    useDummyData();
                }
            }, 3000);
        });

        // Initialize map with better error handling
        function initMap() {
            try {
                console.log('üó∫Ô∏è Initializing map...');
                updateStatus('üó∫Ô∏è Setting up map...');
                
                map = L.map('map').setView([32.0, -97.0], 6);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);

                // Setup buffer selection click handler
                map.on('click', function(e) {
                    console.log('üñ±Ô∏è Map clicked at:', e.latlng, 'Buffer mode:', isBufferMode);
                    if (isBufferMode) {
                        console.log('üìç Creating buffer selection...');
                        createBufferSelection(e.latlng);
                    }
                });

                console.log('‚úÖ Base map loaded');
                updateStatus('‚úÖ Map ready, loading data...');
                
                // Setup drawing controls
                setupDrawingControls();
                
                // Always setup buffer controls regardless of draw tools
                setupBufferControls();
                
                // Load data
                loadGeoJSONFromFile();
                
                console.log('‚úÖ Map initialization complete');
                
            } catch (error) {
                console.error('‚ùå Error initializing map:', error);
                updateStatus('‚ùå Error initializing map: ' + error.message);
                
                // Even if map fails, try to force dummy data
                setTimeout(() => {
                    updateStatus('üîß Attempting emergency data load...');
                    useDummyData();
                }, 2000);
            }
        }

        // Setup Leaflet Draw controls with fallback
        function setupDrawingControls() {
            try {
                // Check if L.Draw is available
                if (typeof L.Draw === 'undefined') {
                    console.warn('‚ö†Ô∏è Leaflet Draw not available, using simple selection');
                    setupSimpleSelection();
                    return;
                }
                
                drawnItems = new L.FeatureGroup();
                map.addLayer(drawnItems);

                const drawControl = new L.Control.Draw({
                    position: 'topright',
                    draw: {
                        polygon: true,
                        rectangle: true,
                        circle: true,
                        polyline: false,
                        marker: false,
                        circlemarker: false
                    },
                    edit: {
                        featureGroup: drawnItems,
                        remove: true
                    }
                });
                map.addControl(drawControl);

                // Handle drawing events
                map.on(L.Draw.Event.CREATED, function(e) {
                    const layer = e.layer;
                    drawnItems.addLayer(layer);
                    selectFeaturesInDrawnArea(layer);
                });

                map.on(L.Draw.Event.DELETED, function(e) {
                    selectedFeatures = [];
                    updateSummary();
                    resetHighlight();
                });
                
                console.log('‚úÖ Leaflet Draw tools loaded');
                updateStatus('‚úÖ Drawing tools loaded');
                
            } catch (error) {
                console.error('‚ùå Error setting up draw controls:', error);
                setupSimpleSelection();
            }
        }

        // Fallback: Simple click selection if draw tools fail
        function setupSimpleSelection() {
            console.log('üîß Setting up simple click selection as fallback');
            updateStatus('‚ÑπÔ∏è Click polygons to select them, or use buffer selection');
            
            // Update only the mode info, keep the buffer tool
            const modeInfo = document.getElementById('modeInfo');
            if (modeInfo) {
                modeInfo.textContent = 'Click individual polygons to select them';
            }
            
            // Keep the buffer tool visible and functional
            console.log('‚úÖ Buffer tool preserved in fallback mode');
        }

        // Clear selections - works with both draw tools and simple selection
        function clearAllSelections() {
            console.log('üóëÔ∏è Clearing all selections...');
            selectedFeatures = [];
            
            // Clear drawn items if draw tools are available
            if (drawnItems) {
                drawnItems.clearLayers();
            }
            
            // Exit buffer mode
            if (isBufferMode) {
                toggleBufferMode();
            }
            
            resetHighlight();
            updateSummary();
            updateStatus('‚úÖ Selections cleared');
        }

        // Setup buffer controls
        function setupBufferControls() {
            console.log('üîß Setting up buffer controls...');
            
            const bufferRange = document.getElementById('bufferRange');
            const bufferValue = document.getElementById('bufferValue');
            const bufferBtn = document.getElementById('bufferBtn');
            
            console.log('Buffer elements found:', {
                range: !!bufferRange,
                value: !!bufferValue, 
                button: !!bufferBtn
            });
            
            if (bufferRange && bufferValue) {
                bufferRange.addEventListener('input', function() {
                    bufferRadius = parseInt(this.value);
                    bufferValue.textContent = bufferRadius + ' miles';
                    console.log('üéöÔ∏è Buffer radius changed to:', bufferRadius, 'miles');
                });
                
                // Set initial value
                bufferValue.textContent = bufferRadius + ' miles';
                console.log('‚úÖ Buffer controls initialized');
            } else {
                console.error('‚ùå Buffer controls not found in DOM');
            }
            
            // Ensure buffer button is visible and functional
            if (bufferBtn) {
                bufferBtn.style.display = 'inline-block';
                console.log('‚úÖ Buffer button made visible');
            }
        }

        // Toggle buffer selection mode
        function toggleBufferMode() {
            isBufferMode = !isBufferMode;
            const bufferBtn = document.getElementById('bufferBtn');
            const bufferControls = document.getElementById('bufferControls');
            const modeInfo = document.getElementById('modeInfo');
            
            console.log('üîÑ Buffer mode toggled:', isBufferMode);
            
            if (isBufferMode) {
                bufferBtn.classList.add('buffer-active');
                bufferBtn.textContent = '‚úã Exit Buffer Mode';
                bufferControls.style.display = 'flex';
                modeInfo.textContent = `Click map to select areas within ${bufferRadius} mile radius`;
                map.getContainer().style.cursor = 'crosshair';
                updateStatus(`üìç Buffer mode active - Click map to select within ${bufferRadius} miles`);
                
                // Make sure buffer controls are visible
                const bufferRange = document.getElementById('bufferRange');
                const bufferValue = document.getElementById('bufferValue');
                if (bufferRange && bufferValue) {
                    bufferValue.textContent = bufferRadius + ' miles';
                    console.log('‚úÖ Buffer controls visible');
                }
            } else {
                bufferBtn.classList.remove('buffer-active');
                bufferBtn.textContent = 'üìç Buffer Select';
                bufferControls.style.display = 'none';
                modeInfo.textContent = 'Use drawing tools in top-right corner of map';
                map.getContainer().style.cursor = '';
                updateStatus('‚ÑπÔ∏è Buffer mode disabled');
            }
        }

        // Create buffer selection around a point
        function createBufferSelection(latlng) {
            console.log(`üéØ Creating ${bufferRadius} mile buffer at`, latlng);
            
            // Clear any existing selection highlights first
            resetHighlight();
            
            // Remove any existing buffer circles
            if (drawnItems) {
                drawnItems.clearLayers();
            }
            
            // Create a visible circle to show the buffer area
            const bufferCircle = L.circle(latlng, {
                radius: bufferRadius * 1609.34, // Convert miles to meters for Leaflet circle
                color: '#ff7800',
                fillColor: '#ff7800',
                fillOpacity: 0.3,
                weight: 3,
                opacity: 0.8
            });
            
            // Add to map immediately
            bufferCircle.addTo(map);
            
            // Add to drawn items for cleanup
            if (drawnItems) {
                drawnItems.addLayer(bufferCircle);
            }
            
            // Select features within buffer
            selectFeaturesInBuffer(latlng, bufferRadius / 69); // Convert miles to degrees
            
            // Keep buffer mode active (don't auto-exit)
            updateStatus(`üìç Selected ${selectedFeatures.length} areas within ${bufferRadius} miles`);
        }

        // Select features within buffer radius
        function selectFeaturesInBuffer(centerPoint, radiusInDegrees) {
            console.log(`üîç Checking features within ${radiusInDegrees.toFixed(4)} degrees of`, centerPoint);
            selectedFeatures = [];
            
            if (!geoJsonLayer) {
                console.warn('No geoJsonLayer available for buffer selection');
                return;
            }

            let checkedCount = 0;
            let selectedCount = 0;

            geoJsonLayer.eachLayer(function(layer) {
                const feature = layer.feature;
                checkedCount++;
                
                if (isFeatureInBuffer(feature, centerPoint, radiusInDegrees)) {
                    selectedFeatures.push({feature: feature, layer: layer});
                    layer.setStyle(highlightStyle(feature));
                    selectedCount++;
                    console.log(`‚úÖ Selected: ${feature.properties.County} (${feature.properties.VTD})`);
                } else {
                    layer.setStyle(style(feature));
                }
            });
            
            console.log(`üìç Buffer selection complete: ${selectedCount}/${checkedCount} features selected`);
            updateSummary();
        }

        // Check if feature is within buffer radius (improved algorithm)
        function isFeatureInBuffer(feature, centerPoint, radiusInDegrees) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.warn('Feature missing geometry');
                return false;
            }
            
            try {
                if (feature.geometry.type === 'Polygon') {
                    // Get the polygon coordinates
                    const coords = feature.geometry.coordinates[0];
                    
                    // Check if the polygon center or any vertex is within the buffer
                    let minDistance = Infinity;
                    let totalLat = 0, totalLng = 0;
                    
                    // Calculate polygon centroid and check all vertices
                    for (let i = 0; i < coords.length - 1; i++) { // -1 to skip duplicate last point
                        const pointLng = coords[i][0];
                        const pointLat = coords[i][1];
                        
                        totalLat += pointLat;
                        totalLng += pointLng;
                        
                        // Calculate distance from center point to this vertex
                        const distance = Math.sqrt(
                            Math.pow(pointLat - centerPoint.lat, 2) + 
                            Math.pow(pointLng - centerPoint.lng, 2)
                        );
                        
                        minDistance = Math.min(minDistance, distance);
                        
                        // If any vertex is within radius, include the polygon
                        if (distance <= radiusInDegrees) {
                            return true;
                        }
                    }
                    
                    // Also check if polygon centroid is within radius
                    const centroidLat = totalLat / (coords.length - 1);
                    const centroidLng = totalLng / (coords.length - 1);
                    const centroidDistance = Math.sqrt(
                        Math.pow(centroidLat - centerPoint.lat, 2) + 
                        Math.pow(centroidLng - centerPoint.lng, 2)
                    );
                    
                    return centroidDistance <= radiusInDegrees;
                }
                return false;
            } catch (e) {
                console.error('Error in buffer check for feature:', feature.properties.County, e);
                return false;
            }
        }

        // Setup county filter
        function setupCountyFilter(data) {
            console.log('üèõÔ∏è Setting up county filter...');
            
            // Extract unique counties
            const counties = [...new Set(data.features.map(f => f.properties.County || 'Unknown'))].sort();
            selectedCounties = new Set(counties); // Start with all selected
            
            const countyFilter = document.getElementById('countyFilter');
            if (!countyFilter) return;
            
            countyFilter.innerHTML = '';
            
            counties.forEach(county => {
                const item = document.createElement('div');
                item.className = 'county-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'county-checkbox';
                checkbox.id = 'county_' + county.replace(/\s+/g, '_');
                checkbox.checked = true;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedCounties.add(county);
                    } else {
                        selectedCounties.delete(county);
                    }
                    applyAllFilters();
                });
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = county;
                label.style.fontSize = '11px';
                label.style.cursor = 'pointer';
                
                item.appendChild(checkbox);
                item.appendChild(label);
                countyFilter.appendChild(item);
            });
            
            console.log(`‚úÖ County filter ready with ${counties.length} counties`);
        }

        // Select all counties
        function selectAllCounties() {
            const checkboxes = document.querySelectorAll('.county-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
                const county = cb.id.replace('county_', '').replace(/_/g, ' ');
                selectedCounties.add(county);
            });
            applyAllFilters();
        }

        // Select no counties
        function selectNoCounties() {
            const checkboxes = document.querySelectorAll('.county-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
                const county = cb.id.replace('county_', '').replace(/_/g, ' ');
                selectedCounties.delete(county);
            });
            applyAllFilters();
        }

        // Load GeoJSON data with better error handling
        async function loadGeoJSONFromFile() {
            console.log('üìÅ Attempting to load prop3.geojson...');
            updateStatus('üîÑ Looking for prop3.geojson...');
            
            try {
                const response = await fetch('prop3.geojson');
                if (response.ok) {
                    const geojson = await response.json();
                    console.log('‚úÖ Loaded external file with', geojson.features?.length, 'features');
                    updateStatus('‚úÖ Loaded prop3.geojson successfully!');
                    processGeoJSON(geojson);
                    return;
                } else {
                    console.log('‚ö†Ô∏è prop3.geojson returned', response.status);
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Could not load prop3.geojson:', error.message);
            }
            
            // Always fall back to dummy data
            console.log('üß™ Loading dummy data for testing...');
            updateStatus('üß™ Loading test data (prop3.geojson not found)...');
            
            // Small delay to show the message
            setTimeout(() => {
                useDummyData();
            }, 500);
        }

        // Update status message
        function updateStatus(message) {
            const statusEl = document.getElementById('statusMessage');
            if (statusEl) {
                statusEl.innerHTML = message;
            }
        }

        // Create dummy data - more robust and visible
        function useDummyData() {
            try {
                console.log('üß™ Creating visible dummy data...');
                updateStatus('üß™ Creating 20 test districts...');
                
                const features = [];
                const counties = ["Jefferson", "Harris", "Dallas", "Travis", "Bexar", "Williamson", "Collin", "Fort Bend", "Denton", "Hays", "Brazoria", "Galveston", "Montgomery", "Tarrant", "Bell", "Parker", "Ellis", "Johnson", "Kaufman", "Henderson"];
                const demPercentages = [0.65, 0.672, 0.729, 0.734, 0.671, 0.58, 0.576, 0.573, 0.573, 0.56, 0.49, 0.491, 0.404, 0.446, 0.457, 0.257, 0.302, 0.295, 0.282, 0.274];
                
                let id = 1;
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (id > 20) break;
                        
                        // Create large, well-spaced squares across Texas
                        const lng = -99.0 + (col * 1.2); // More spacing
                        const lat = 29.0 + (row * 1.2);
                        const size = 0.8; // Smaller squares with gaps
                        
                        const county = counties[id - 1];
                        const demPct = demPercentages[id - 1];
                        const dem = Math.round(500 + demPct * 1000);
                        const rep = Math.round(1500 - dem);
                        
                        const coordinates = [[
                            [lng, lat],
                            [lng + size, lat],
                            [lng + size, lat + size],
                            [lng, lat + size],
                            [lng, lat]
                        ]];
                        
                        const feature = {
                            "type": "Feature",
                            "properties": {
                                "County": county,
                                "VTD": String(id).padStart(3, '0'),
                                "Dem": dem,
                                "Rep": rep,
                                "Total": dem + rep,
                                "Dem_pct": demPct,
                                "Rep_pct": (1 - demPct),
                                "White_Vap_pct": 0.3 + Math.random() * 0.5,
                                "Black_Vap_pct": Math.random() * 0.4,
                                "Asian_Vap_pct": Math.random() * 0.2,
                                "Hispanic_Vap_pct": Math.random() * 0.5,
                                "vap": Math.round((dem + rep) * 1.2),
                                "anglovap": Math.round((dem + rep) * 0.6),
                                "blackvap": Math.round((dem + rep) * 0.15),
                                "hispvap": Math.round((dem + rep) * 0.2),
                                "asianvap": Math.round((dem + rep) * 0.05)
                            },
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": coordinates
                            }
                        };
                        
                        features.push(feature);
                        const pctDisplay = (demPct * 100).toFixed(1);
                        console.log(`‚úÖ ${county}: ${pctDisplay}% Dem (${demPct < 0.5 ? 'RED' : 'BLUE'})`);
                        id++;
                    }
                }
                
                const dummyData = {
                    "type": "FeatureCollection", 
                    "features": features
                };
                
                console.log('‚úÖ Created', features.length, 'test districts');
                console.log('Expected colors: RED (Parker 26%), BLUE (Travis 73%)');
                
                processGeoJSON(dummyData);
                
            } catch (error) {
                console.error('‚ùå Error creating dummy data:', error);
                updateStatus('‚ùå Error creating test data: ' + error.message);
            }
        }

        // Process GeoJSON data with robust error handling
        function processGeoJSON(geojson) {
            try {
                console.log('üîÑ Processing GeoJSON data...');
                
                if (!geojson || !geojson.features || geojson.features.length === 0) {
                    throw new Error('Invalid or empty GeoJSON data');
                }
                
                originalData = geojson;
                console.log('‚úÖ Data stored:', geojson.features.length, 'features');
                
                // Setup filters first
                setupFilters();
                console.log('‚úÖ Filters configured');
                
                // Setup county filter
                setupCountyFilter(geojson);
                console.log('‚úÖ County filter configured');
                
                // Load onto map
                loadGeoJSON(geojson);
                console.log('‚úÖ Map loaded');
                
                // Update status
                const featureCount = geojson.features.length;
                const countyCount = new Set(geojson.features.map(f => f.properties.County)).size;
                updateStatus(`‚úÖ Ready! ${featureCount} districts, ${countyCount} counties loaded.`);
                
                // Force a sample color check
                const sampleFeature = geojson.features[0];
                const sampleDemPct = sampleFeature.properties.Dem_pct;
                const sampleColor = getColor(sampleDemPct);
                console.log(`üé® Sample: ${sampleFeature.properties.County} = ${(sampleDemPct*100).toFixed(1)}% Dem ‚Üí ${sampleColor}`);
                
                console.log('‚úÖ GeoJSON processing completed successfully');
                
            } catch (error) {
                console.error('‚ùå Error processing GeoJSON:', error);
                updateStatus('‚ùå Error processing data: ' + error.message);
                
                // Try to still show the interface
                setTimeout(() => {
                    updateStatus('‚ÑπÔ∏è Interface ready, but data failed to load');
                }, 1000);
            }
        }

        // Setup filter sliders
        function setupFilters() {
            const filters = ['dem', 'rep', 'white', 'black', 'hispanic', 'asian'];
            
            filters.forEach(filter => {
                const slider = document.getElementById(filter + 'Slider');
                const value = document.getElementById(filter + 'Value');
                
                if (slider && value) {
                    slider.addEventListener('input', function() {
                        value.textContent = `Show areas ‚â• ${this.value}%`;
                        applyAllFilters();
                    });
                }
            });
        }

        // Apply all filters (demographic + county)
        function applyAllFilters() {
            if (!originalData) return;
            
            const filters = {
                dem: parseInt(document.getElementById('demSlider').value) / 100, // Convert to decimal
                rep: parseInt(document.getElementById('repSlider').value) / 100,
                white: parseInt(document.getElementById('whiteSlider').value) / 100,
                black: parseInt(document.getElementById('blackSlider').value) / 100,
                hispanic: parseInt(document.getElementById('hispanicSlider').value) / 100,
                asian: parseInt(document.getElementById('asianSlider').value) / 100
            };
            
            const filteredData = {
                ...originalData,
                features: originalData.features.filter(feature => {
                    const props = feature.properties;
                    
                    // County filter
                    const county = props.County || 'Unknown';
                    if (!selectedCounties.has(county)) {
                        return false;
                    }
                    
                    // Demographic filters
                    return (props.Dem_pct || 0) >= filters.dem &&
                           (props.Rep_pct || 0) >= filters.rep &&
                           (props.White_Vap_pct || 0) >= filters.white &&
                           (props.Black_Vap_pct || 0) >= filters.black &&
                           (props.Hispanic_Vap_pct || 0) >= filters.hispanic &&
                           (props.Asian_Vap_pct || 0) >= filters.asian;
                })
            };
            
            loadGeoJSON(filteredData);
            selectedFeatures = [];
            updateSummary();
            
            const visibleCount = filteredData.features.length;
            const totalCount = originalData.features.length;
            console.log(`üîç Filters applied: ${visibleCount}/${totalCount} features visible`);
        }

        // Color coding - handle decimal percentages (0.65 = 65%)
        function getColor(demPct) {
            const pct = (parseFloat(demPct) || 0) * 100; // Convert decimal to percentage
            console.log('Coloring polygon with Dem_pct:', demPct, '‚Üí', pct + '%');
            
            if (pct < 20) return '#8b0000';      // Dark red
            if (pct < 40) return '#dc143c';      // Medium red
            if (pct < 49) return '#ff6b6b';      // Light red
            if (pct < 60) return '#4dabf7';      // Light blue
            return '#1864ab';                    // Dark blue
        }

        // Style polygons
        function style(feature) {
            const demPct = parseFloat(feature.properties.Dem_pct) || 0;
            return {
                fillColor: getColor(demPct),
                weight: 1,
                opacity: 1,
                color: 'white',
                fillOpacity: 0.7
            };
        }

        // Highlight style
        function highlightStyle(feature) {
            return {
                fillColor: getColor(feature.properties.Dem_pct),
                weight: 3,
                color: '#ffff00',
                fillOpacity: 0.9
            };
        }

        // Load GeoJSON onto map
        function loadGeoJSON(geojson) {
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            geoJsonLayer = L.geoJSON(geojson, {
                style: style,
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    const demPct = (parseFloat(props.Dem_pct) || 0) * 100; // Convert to percentage for display
                    
                    layer.bindTooltip(`
                        <strong>County:</strong> ${props.County || 'N/A'}<br>
                        <strong>VTD:</strong> ${props.VTD || 'N/A'}<br>
                        <strong>Dem %:</strong> ${demPct.toFixed(1)}%
                    `);

                    layer.on('click', function(e) {
                        toggleFeatureSelection(feature, layer);
                        L.DomEvent.stopPropagation(e);
                    });
                }
            }).addTo(map);

            map.fitBounds(geoJsonLayer.getBounds(), {padding: [20, 20]});
        }

        // Select features in drawn area
        function selectFeaturesInDrawnArea(drawnLayer) {
            console.log('üéØ Selecting features in drawn area...');
            selectedFeatures = [];
            
            if (!geoJsonLayer) return;

            geoJsonLayer.eachLayer(function(layer) {
                const feature = layer.feature;
                if (isFeatureInDrawnArea(feature, drawnLayer)) {
                    selectedFeatures.push({feature: feature, layer: layer});
                    layer.setStyle(highlightStyle(feature));
                } else {
                    layer.setStyle(style(feature));
                }
            });
            
            console.log(`Selected ${selectedFeatures.length} features`);
            updateSummary();
        }

        // Check if feature intersects with drawn area
        function isFeatureInDrawnArea(feature, drawnLayer) {
            if (!feature.geometry || !feature.geometry.coordinates) return false;
            
            try {
                const drawnBounds = drawnLayer.getBounds();
                
                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    return coords.some(coord => {
                        return drawnBounds.contains([coord[1], coord[0]]);
                    });
                }
                return false;
            } catch (e) {
                console.error('Error in intersection check:', e);
                return false;
            }
        }

        // Toggle feature selection
        function toggleFeatureSelection(feature, layer) {
            const index = selectedFeatures.findIndex(f => f.feature === feature);
            
            if (index > -1) {
                selectedFeatures.splice(index, 1);
                layer.setStyle(style(feature));
            } else {
                selectedFeatures.push({feature: feature, layer: layer});
                layer.setStyle(highlightStyle(feature));
            }
            
            updateSummary();
        }

        // Reset highlights
        function resetHighlight() {
            if (geoJsonLayer) {
                geoJsonLayer.eachLayer(function(layer) {
                    layer.setStyle(style(layer.feature));
                });
            }
        }

        // Update summary
        function updateSummary() {
            const summaryContent = document.getElementById('summaryContent');
            
            if (selectedFeatures.length === 0) {
                summaryContent.innerHTML = '<p style="color: #666; text-align: center; font-size: 12px;">Select areas to view data</p>';
                return;
            }

            const aggregated = aggregateData(selectedFeatures.map(sf => sf.feature.properties));
            
            let html = `<div class="summary-item">
                <span class="summary-label">Selected Areas:</span>
                <span class="summary-value">${selectedFeatures.length}</span>
            </div>`;
            
            Object.entries(aggregated).forEach(([key, value]) => {
                let displayValue;
                if (key.includes('_pct') || key.includes('_Pct')) {
                    // Convert decimal percentages to display format
                    displayValue = `${(value * 100).toFixed(1)}%`;
                } else {
                    displayValue = value.toLocaleString();
                }
                
                html += `<div class="summary-item">
                    <span class="summary-label">${formatLabel(key)}:</span>
                    <span class="summary-value">${displayValue}</span>
                </div>`;
            });
            
            summaryContent.innerHTML = html;
        }

        // Aggregate data
        function aggregateData(propertiesArray) {
            if (propertiesArray.length === 0) return {};
            
            const result = {};
            const sampleProps = propertiesArray[0];
            
            Object.keys(sampleProps).forEach(key => {
                if (key === 'geometry' || key === 'GEOID' || key === 'PCTKEY') return;
                
                const values = propertiesArray.map(p => parseFloat(p[key]) || 0).filter(v => !isNaN(v));
                if (values.length === 0) return;
                
                if (key.includes('_pct') || key.includes('_Pct')) {
                    result[key] = values.reduce((sum, val) => sum + val, 0) / values.length;
                } else if (['Dem', 'Rep', 'Total'].includes(key) || key.endsWith('vap')) {
                    result[key] = values.reduce((sum, val) => sum + val, 0);
                }
            });
            
            return result;
        }

        // Format labels
        function formatLabel(key) {
            return key.replace(/_/g, ' ')
                     .replace(/pct/gi, '%')
                     .replace(/vap/gi, 'VAP')
                     .replace(/\b\w/g, l => l.toUpperCase());
        }
    </script>
</body>
</html>