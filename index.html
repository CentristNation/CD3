<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proposed CD 3 Data Analytics</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid #007bff;
        }
        
        .main-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 0;
            line-height: 1.3;
        }
        
        .subtitle {
            font-size: 13px;
            color: #666;
            margin: 3px 0 0 0;
        }
        
        .status-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            font-size: 13px;
            border-left: 4px solid #007bff;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.8);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }
        
        .selection-tools {
            text-align: center;
        }
        
        .tool-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .tool-button:hover {
            background: #0056b3;
        }
        
        .tool-button.active {
            background: #28a745;
        }
        
        .filter-item {
            margin-bottom: 12px;
        }
        
        .filter-label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .party-icon {
            width: 20px;
            height: 20px;
            margin-right: 6px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dem-icon { color: #0066cc; }
        .rep-icon { color: #cc0000; }
        
        .filter-slider {
            width: 100%;
            margin: 3px 0;
        }
        
        .filter-value {
            font-size: 11px;
            color: #666;
            text-align: center;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }
        
        .summary-label {
            font-weight: 500;
            color: #555;
        }
        
        .summary-value {
            font-weight: bold;
            color: #333;
        }
        
        .legend {
            position: absolute;
            bottom: 60px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 12px;
        }
        
        .legend h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 13px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }
        
        .legend-color {
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #ccc;
        }
        
        .credit {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 11px;
            color: #666;
            z-index: 1000;
        }
        
        .mode-info {
            font-size: 10px;
            margin-top: 5px;
            color: #666;
            text-align: center;
        }
        
        .county-filter {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 8px;
            background: white;
        }
        
        .county-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
            font-size: 11px;
        }
        
        .county-checkbox {
            margin-right: 6px;
        }
        
        .county-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .county-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .county-btn:hover {
            background: #5a6268;
        }
        
        .buffer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .buffer-input {
            flex: 1;
        }
        
        .buffer-value {
            font-size: 11px;
            color: #666;
            min-width: 60px;
        }
        
        .buffer-active {
            background: #28a745 !important;
            color: white !important;
        }
        
        .buffer-active:hover {
            background: #218838 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1 class="main-title">Proposed CD 3 Data Analytics</h1>
                <p class="subtitle">By Ifte Islam PhD</p>
            </div>
            
            <div class="status-message" id="statusMessage">
                Loading data...
            </div>
            
            <div class="section" id="selectionSection">
                <div class="section-title">Selection Tools</div>
                <div class="selection-tools">
                    <button class="tool-button" id="bufferBtn" onclick="toggleBufferMode()">Buffer Select</button>
                    <button class="tool-button" id="clearSelection" onclick="clearAllSelections()">Clear All</button>
                    <div class="mode-info" id="modeInfo">Use drawing tools in top-right corner of map</div>
                    <div class="buffer-controls" id="bufferControls" style="display: none;">
                        <input type="range" class="buffer-input" id="bufferRange" min="1" max="50" value="10">
                        <div class="buffer-value" id="bufferValue">10 miles</div>
                    </div>
                </div>
            </div>
            
            <div class="section" id="countySection">
                <div class="section-title">County Filter</div>
                <div class="county-controls">
                    <button class="county-btn" onclick="selectAllCounties()">All</button>
                    <button class="county-btn" onclick="selectNoCounties()">None</button>
                </div>
                <div class="county-filter" id="countyFilter">
                    <div style="text-align: center; color: #666; font-size: 11px;">Loading counties...</div>
                </div>
            </div>
            
            <div class="section" id="filterSection">
                <div class="section-title">Filters (Min %)</div>
                
                <div class="filter-item">
                    <div class="filter-label">
                        <div class="party-icon dem-icon">D</div>
                        Democratic %
                    </div>
                    <input type="range" class="filter-slider" id="demSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="demValue">Show areas ≥ 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">
                        <div class="party-icon rep-icon">R</div>
                        Republican %
                    </div>
                    <input type="range" class="filter-slider" id="repSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="repValue">Show areas ≥ 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">White %</div>
                    <input type="range" class="filter-slider" id="whiteSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="whiteValue">Show areas ≥ 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Black %</div>
                    <input type="range" class="filter-slider" id="blackSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="blackValue">Show areas ≥ 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Hispanic %</div>
                    <input type="range" class="filter-slider" id="hispanicSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="hispanicValue">Show areas ≥ 0%</div>
                </div>
                
                <div class="filter-item">
                    <div class="filter-label">Asian %</div>
                    <input type="range" class="filter-slider" id="asianSlider" min="0" max="100" value="0">
                    <div class="filter-value" id="asianValue">Show areas ≥ 0%</div>
                </div>
            </div>
            
            <div class="section" id="summarySection">
                <div class="section-title">Selected Area Summary</div>
                <div id="summaryContent">
                    <p style="color: #666; text-align: center; font-size: 12px;">Select areas to view data</p>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="legend" id="legend">
                <h4>Democratic %</h4>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #8b0000;"></div>
                    <span>0-20%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc143c;"></div>
                    <span>20-40%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <span>40-49%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4dabf7;"></div>
                    <span>50-60%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #1864ab;"></div>
                    <span>60%+</span>
                </div>
            </div>
            <div class="credit">PrecinctSmart.com</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script>
        let map, geoJsonLayer, selectedFeatures = [];
        let originalData = null;
        let drawnItems = null;
        let isBufferMode = false;
        let selectedCounties = new Set();
        let bufferRadius = 10; // miles

        // Initialize on page load with better library loading
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Starting application...');
            
            // Wait for all scripts to load before initializing
            setTimeout(() => {
                updateStatus('Initializing map and interface...');
                initMap();
            }, 500);
            
            // Force load dummy data as backup after 5 seconds if nothing else worked
            setTimeout(() => {
                if (!originalData) {
                    console.log('Emergency fallback: forcing dummy data load');
                    updateStatus('Fallback: Loading test data...');
                    useDummyData();
                }
            }, 5000);
        });

        // Wait for Leaflet Draw to load properly
        function waitForLeafletDraw(callback, maxAttempts = 10) {
            let attempts = 0;
            
            function checkForDraw() {
                attempts++;
                
                if (typeof L !== 'undefined' && typeof L.Draw !== 'undefined' && typeof L.Control.Draw !== 'undefined') {
                    console.log('Leaflet Draw loaded successfully after', attempts, 'attempts');
                    callback(true);
                } else if (attempts >= maxAttempts) {
                    console.warn('Leaflet Draw failed to load after', maxAttempts, 'attempts');
                    callback(false);
                } else {
                    console.log('Waiting for Leaflet Draw... attempt', attempts);
                    setTimeout(checkForDraw, 200);
                }
            }
            
            checkForDraw();
        }

        // Initialize map with better error handling
        function initMap() {
            try {
                console.log('Initializing map...');
                updateStatus('Setting up map...');
                
                map = L.map('map').setView([32.0, -97.0], 6);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);

                // Setup buffer selection click handler
                map.on('click', function(e) {
                    console.log('Map clicked at:', e.latlng, 'Buffer mode:', isBufferMode);
                    if (isBufferMode) {
                        console.log('Creating buffer selection...');
                        createBufferSelection(e.latlng);
                    }
                });

                console.log('Base map loaded');
                updateStatus('Map ready, loading data...');
                
                // Setup drawing controls
                setupDrawingControls();
                
                // Always setup buffer controls regardless of draw tools
                setupBufferControls();
                
                // Load data
                loadGeoJSONFromFile();
                
                console.log('Map initialization complete');
                
            } catch (error) {
                console.error('Error initializing map:', error);
                updateStatus('Error initializing map: ' + error.message);
                
                // Even if map fails, try to force dummy data
                setTimeout(() => {
                    updateStatus('Attempting emergency data load...');
                    useDummyData();
                }, 2000);
            }
        }

        // Setup Leaflet Draw controls with proper loading detection
        function setupDrawingControls() {
            console.log('Setting up drawing controls...');
            updateStatus('Loading drawing tools...');
            
            waitForLeafletDraw(function(loaded) {
                if (loaded) {
                    try {
                        drawnItems = new L.FeatureGroup();
                        map.addLayer(drawnItems);

                        const drawControl = new L.Control.Draw({
                            position: 'topright',
                            draw: {
                                polygon: {
                                    shapeOptions: {
                                        color: '#97009c',
                                        weight: 4
                                    }
                                },
                                rectangle: {
                                    shapeOptions: {
                                        color: '#97009c',
                                        weight: 4
                                    }
                                },
                                circle: {
                                    shapeOptions: {
                                        color: '#97009c',
                                        weight: 4
                                    }
                                },
                                polyline: false,
                                marker: false,
                                circlemarker: false
                            },
                            edit: {
                                featureGroup: drawnItems,
                                remove: true,
                                edit: true
                            }
                        });
                        map.addControl(drawControl);

                        // Handle drawing events
                        map.on(L.Draw.Event.CREATED, function(e) {
                            const layer = e.layer;
                            drawnItems.addLayer(layer);
                            selectFeaturesInDrawnArea(layer);
                            updateStatus(`Selected ${selectedFeatures.length} features in drawn area`);
                        });

                        map.on(L.Draw.Event.DELETED, function(e) {
                            selectedFeatures = [];
                            updateSummary();
                            resetHighlight();
                            updateStatus('Drawn selections cleared');
                        });

                        map.on(L.Draw.Event.EDITED, function(e) {
                            // Reselect features for all edited shapes
                            selectedFeatures = [];
                            drawnItems.eachLayer(function(layer) {
                                selectFeaturesInDrawnArea(layer);
                            });
                            updateStatus(`Updated selection: ${selectedFeatures.length} features`);
                        });
                        
                        console.log('Leaflet Draw tools loaded successfully');
                        updateStatus('Drawing tools ready - use toolbar in top-right corner');
                        
                    } catch (error) {
                        console.error('Error setting up draw controls after loading:', error);
                        setupSimpleSelection();
                    }
                } else {
                    console.warn('Leaflet Draw failed to load, using simple selection');
                    setupSimpleSelection();
                }
            });
        }

        // Fallback: Simple click selection if draw tools fail
        function setupSimpleSelection() {
            console.log('Setting up simple click selection as fallback');
            updateStatus('Click polygons to select them, or use buffer selection');
            
            // Update only the mode info, keep the buffer tool
            const modeInfo = document.getElementById('modeInfo');
            if (modeInfo) {
                modeInfo.textContent = 'Click individual polygons to select them';
            }
            
            // Keep the buffer tool visible and functional
            console.log('Buffer tool preserved in fallback mode');
        }

        // Clear selections - works with both draw tools and simple selection
        function clearAllSelections() {
            console.log('Clearing all selections...');
            selectedFeatures = [];
            
            // Clear drawn items if draw tools are available
            if (drawnItems) {
                drawnItems.clearLayers();
            }
            
            // Fallback: manually remove buffer circle if stored
            if (window.lastBufferCircle) {
                map.removeLayer(window.lastBufferCircle);
                window.lastBufferCircle = null;
            }
            
            // Exit buffer mode
            if (isBufferMode) {
                toggleBufferMode();
            }
            
            resetHighlight();
            updateSummary();
            updateStatus('Selections cleared');
        }

        // Setup buffer controls
        function setupBufferControls() {
            console.log('Setting up buffer controls...');
            
            const bufferRange = document.getElementById('bufferRange');
            const bufferValue = document.getElementById('bufferValue');
            const bufferBtn = document.getElementById('bufferBtn');
            
            console.log('Buffer elements found:', {
                range: !!bufferRange,
                value: !!bufferValue, 
                button: !!bufferBtn
            });
            
            if (bufferRange && bufferValue) {
                bufferRange.addEventListener('input', function() {
                    bufferRadius = parseInt(this.value);
                    bufferValue.textContent = bufferRadius + ' miles';
                    console.log('Buffer radius changed to:', bufferRadius, 'miles');
                });
                
                // Set initial value
                bufferValue.textContent = bufferRadius + ' miles';
                console.log('Buffer controls initialized');
            } else {
                console.error('Buffer controls not found in DOM');
            }
            
            // Ensure buffer button is visible and functional
            if (bufferBtn) {
                bufferBtn.style.display = 'inline-block';
                console.log('Buffer button made visible');
            }
        }

        // Toggle buffer selection mode
        function toggleBufferMode() {
            isBufferMode = !isBufferMode;
            const bufferBtn = document.getElementById('bufferBtn');
            const bufferControls = document.getElementById('bufferControls');
            const modeInfo = document.getElementById('modeInfo');
            
            console.log('Buffer mode toggled:', isBufferMode);
            
            if (isBufferMode) {
                bufferBtn.classList.add('buffer-active');
                bufferBtn.textContent = 'Exit Buffer Mode';
                bufferControls.style.display = 'flex';
                modeInfo.textContent = `Click map to select areas within ${bufferRadius} mile radius`;
                map.getContainer().style.cursor = 'crosshair';
                updateStatus(`Buffer mode active - Click map to select within ${bufferRadius} miles`);
                
                // Make sure buffer controls are visible
                const bufferRange = document.getElementById('bufferRange');
                const bufferValue = document.getElementById('bufferValue');
                if (bufferRange && bufferValue) {
                    bufferValue.textContent = bufferRadius + ' miles';
                    console.log('Buffer controls visible');
                }
            } else {
                bufferBtn.classList.remove('buffer-active');
                bufferBtn.textContent = 'Buffer Select';
                bufferControls.style.display = 'none';
                modeInfo.textContent = 'Use drawing tools in top-right corner of map';
                map.getContainer().style.cursor = '';
                updateStatus('Buffer mode disabled');
            }
        }

        // Create buffer selection around a point
        function createBufferSelection(latlng) {
            console.log(`Creating ${bufferRadius} mile buffer at`, latlng);
            
            // Clear any existing selection highlights first
            resetHighlight();
            
            // Remove any existing buffer circles
            if (drawnItems) {
                drawnItems.clearLayers();
            }
            
            // Create a visible circle to show the buffer area
            const bufferCircle = L.circle(latlng, {
                radius: bufferRadius * 1609.34, // Convert miles to meters for Leaflet circle
                color: '#ff7800',
                fillColor: '#ff7800',
                fillOpacity: 0.3,
                weight: 3,
                opacity: 0.8
            });
            
            // Add to drawnItems for proper cleanup
            if (drawnItems) {
                drawnItems.addLayer(bufferCircle);
            } else {
                // Fallback: add directly to map if drawnItems not available
                bufferCircle.addTo(map);
                window.lastBufferCircle = bufferCircle;
            }
            
            // Select features within buffer using proper distance calculation
            selectFeaturesInBuffer(latlng, bufferRadius);
            
            updateStatus(`Selected ${selectedFeatures.length} areas within ${bufferRadius} miles`);
        }

        // Select features within buffer radius using proper distance calculation
        function selectFeaturesInBuffer(centerPoint, radiusInMiles) {
            console.log(`Checking features within ${radiusInMiles} miles of`, centerPoint);
            selectedFeatures = [];
            
            if (!geoJsonLayer) {
                console.warn('No geoJsonLayer available for buffer selection');
                return;
            }

            let checkedCount = 0;
            let selectedCount = 0;

            geoJsonLayer.eachLayer(function(layer) {
                const feature = layer.feature;
                checkedCount++;
                
                if (isFeatureInBufferMiles(feature, centerPoint, radiusInMiles)) {
                    selectedFeatures.push({feature: feature, layer: layer});
                    layer.setStyle(highlightStyle(feature));
                    selectedCount++;
                    console.log(`Selected: ${feature.properties.County} (${feature.properties.VTD})`);
                } else {
                    layer.setStyle(style(feature));
                }
            });
            
            console.log(`Buffer selection complete: ${selectedCount}/${checkedCount} features selected`);
            updateSummary();
        }

        // Check if feature is within buffer radius using Haversine formula for WGS 84
        function isFeatureInBufferMiles(feature, centerPoint, radiusInMiles) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                return false;
            }
            
            try {
                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    
                    // Calculate polygon centroid
                    let totalLat = 0, totalLng = 0, validPoints = 0;
                    for (let i = 0; i < coords.length - 1; i++) {
                        totalLat += coords[i][1];
                        totalLng += coords[i][0];
                        validPoints++;
                    }
                    
                    if (validPoints === 0) return false;
                    
                    const centroidLat = totalLat / validPoints;
                    const centroidLng = totalLng / validPoints;
                    
                    // Calculate distance using Haversine formula
                    const distance = calculateDistance(
                        centerPoint.lat, centerPoint.lng,
                        centroidLat, centroidLng
                    );
                    
                    // Also check if any vertex is within radius for edge cases
                    let hasVertexInRadius = false;
                    for (let i = 0; i < coords.length - 1 && !hasVertexInRadius; i++) {
                        const vertexDistance = calculateDistance(
                            centerPoint.lat, centerPoint.lng,
                            coords[i][1], coords[i][0]
                        );
                        if (vertexDistance <= radiusInMiles) {
                            hasVertexInRadius = true;
                        }
                    }
                    
                    return distance <= radiusInMiles || hasVertexInRadius;
                }
                return false;
            } catch (e) {
                console.error('Error in buffer check for feature:', feature.properties.County, e);
                return false;
            }
        }

        // Calculate distance between two points using Haversine formula (returns miles)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Setup county filter
        function setupCountyFilter(data) {
            console.log('Setting up county filter...');
            
            // Extract unique counties
            const counties = [...new Set(data.features.map(f => f.properties.County || 'Unknown'))].sort();
            selectedCounties = new Set(counties); // Start with all selected
            
            const countyFilter = document.getElementById('countyFilter');
            if (!countyFilter) return;
            
            countyFilter.innerHTML = '';
            
            counties.forEach(county => {
                const item = document.createElement('div');
                item.className = 'county-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'county-checkbox';
                checkbox.id = 'county_' + county.replace(/\s+/g, '_');
                checkbox.checked = true;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedCounties.add(county);
                    } else {
                        selectedCounties.delete(county);
                    }
                    applyAllFilters();
                });
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = county;
                label.style.fontSize = '11px';
                label.style.cursor = 'pointer';
                
                item.appendChild(checkbox);
                item.appendChild(label);
                countyFilter.appendChild(item);
            });
            
            console.log(`County filter ready with ${counties.length} counties`);
        }

        // Select all counties
        function selectAllCounties() {
            const checkboxes = document.querySelectorAll('.county-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
                const county = cb.id.replace('county_', '').replace(/_/g, ' ');
                selectedCounties.add(county);
            });
            applyAllFilters();
        }

        // Select no counties
        function selectNoCounties() {
            const checkboxes = document.querySelectorAll('.county-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
                const county = cb.id.replace('county_', '').replace(/_/g, ' ');
                selectedCounties.delete(county);
            });
            applyAllFilters();
        }

        // Load GeoJSON data with better error handling
        async function loadGeoJSONFromFile() {
            console.log('Attempting to load prop3.geojson...');
            updateStatus('Looking for prop3.geojson...');
            
            try {
                const response = await fetch('prop3.geojson');
                if (response.ok) {
                    const geojson = await response.json();
                    console.log('Loaded external file with', geojson.features?.length, 'features');
                    updateStatus('Loaded prop3.geojson successfully!');
                    processGeoJSON(geojson);
                    return;
                } else {
                    console.log('prop3.geojson returned', response.status);
                }
            } catch (error) {
                console.log('Could not load prop3.geojson:', error.message);
            }
            
            // Always fall back to dummy data
            console.log('Loading dummy data for testing...');
            updateStatus('Loading test data (prop3.geojson not found)...');
            
            // Small delay to show the message
            setTimeout(() => {
                useDummyData();
            }, 500);
        }

        // Update status message
        function updateStatus(message) {
            const statusEl = document.getElementById('statusMessage');
            if (statusEl) {
                statusEl.innerHTML = message;
            }
        }

        // Create dummy data - using proper percentage format (decimal values)
        function useDummyData() {
            try {
                console.log('Creating visible dummy data...');
                updateStatus('Creating 20 test districts...');
                
                const features = [];
                const counties = ["Jefferson", "Harris", "Dallas", "Travis", "Bexar", "Williamson", "Collin", "Fort Bend", "Denton", "Hays", "Brazoria", "Galveston", "Montgomery", "Tarrant", "Bell", "Parker", "Ellis", "Johnson", "Kaufman", "Henderson"];
                // Percentages already in decimal format (.65 = 65%, .32 = 32%)
                const demPercentages = [0.65, 0.672, 0.729, 0.734, 0.671, 0.58, 0.576, 0.573, 0.573, 0.56, 0.49, 0.491, 0.404, 0.446, 0.457, 0.257, 0.302, 0.295, 0.282, 0.274];
                
                let id = 1;
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (id > 20) break;
                        
                        // Create large, well-spaced squares across Texas
                        const lng = -99.0 + (col * 1.2); // More spacing
                        const lat = 29.0 + (row * 1.2);
                        const size = 0.8; // Smaller squares with gaps
                        
                        const county = counties[id - 1];
                        const demPct = demPercentages[id - 1]; // Already in decimal format
                        const dem = Math.round(500 + demPct * 1000);
                        const rep = Math.round(1500 - dem);
                        
                        const coordinates = [[
                            [lng, lat],
                            [lng + size, lat],
                            [lng + size, lat + size],
                            [lng, lat + size],
                            [lng, lat]
                        ]];
                        
                        const feature = {
                            "type": "Feature",
                            "properties": {
                                "County": county,
                                "VTD": String(id).padStart(3, '0'),
                                "Dem": dem,
                                "Rep": rep,
                                "Total": dem + rep,
                                "Dem_pct": demPct, // Decimal format (.65 = 65%)
                                "Rep_pct": (1 - demPct),
                                "White_Vap_pct": 0.3 + Math.random() * 0.5,
                                "Black_Vap_pct": Math.random() * 0.4,
                                "Asian_Vap_pct": Math.random() * 0.2,
                                "Hispanic_Vap_pct": Math.random() * 0.5,
                                "vap": Math.round((dem + rep) * 1.2),
                                "anglovap": Math.round((dem + rep) * 0.6),
                                "blackvap": Math.round((dem + rep) * 0.15),
                                "hispvap": Math.round((dem + rep) * 0.2),
                                "asianvap": Math.round((dem + rep) * 0.05)
                            },
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": coordinates
                            }
                        };
                        
                        features.push(feature);
                        const pctDisplay = (demPct * 100).toFixed(1);
                        console.log(`${county}: ${pctDisplay}% Dem (${demPct < 0.5 ? 'RED' : 'BLUE'})`);
                        id++;
                    }
                }
                
                const dummyData = {
                    "type": "FeatureCollection", 
                    "features": features
                };
                
                console.log('Created', features.length, 'test districts');
                console.log('Expected colors: RED (Parker 26%), BLUE (Travis 73%)');
                
                processGeoJSON(dummyData);
                
            } catch (error) {
                console.error('Error creating dummy data:', error);
                updateStatus('Error creating test data: ' + error.message);
            }
        }

        // Process GeoJSON data with robust error handling
        function processGeoJSON(geojson) {
            try {
                console.log('Processing GeoJSON data...');
                
                if (!geojson || !geojson.features || geojson.features.length === 0) {
                    throw new Error('Invalid or empty GeoJSON data');
                }
                
                originalData = geojson;
                console.log('Data stored:', geojson.features.length, 'features');
                
                // Setup filters first
                setupFilters();
                console.log('Filters configured');
                
                // Setup county filter
                setupCountyFilter(geojson);
                console.log('County filter configured');
                
                // Load onto map
                loadGeoJSON(geojson);
                console.log('Map loaded');
                
                // Update status
                const featureCount = geojson.features.length;
                const countyCount = new Set(geojson.features.map(f => f.properties.County)).size;
                updateStatus(`Ready! ${featureCount} districts, ${countyCount} counties loaded.`);
                
                // Force a sample color check
                const sampleFeature = geojson.features[0];
                const sampleDemPct = sampleFeature.properties.Dem_pct;
                const sampleColor = getColor(sampleDemPct);
                console.log(`Sample: ${sampleFeature.properties.County} = ${(sampleDemPct*100).toFixed(1)}% Dem → ${sampleColor}`);
                
                console.log('GeoJSON processing completed successfully');
                
            } catch (error) {
                console.error('Error processing GeoJSON:', error);
                updateStatus('Error processing data: ' + error.message);
                
                // Try to still show the interface
                setTimeout(() => {
                    updateStatus('Interface ready, but data failed to load');
                }, 1000);
            }
        }

        // Setup filter sliders
        function setupFilters() {
            const filters = ['dem', 'rep', 'white', 'black', 'hispanic', 'asian'];
            
            filters.forEach(filter => {
                const slider = document.getElementById(filter + 'Slider');
                const value = document.getElementById(filter + 'Value');
                
                if (slider && value) {
                    slider.addEventListener('input', function() {
                        value.textContent = `Show areas ≥ ${this.value}%`;
                        applyAllFilters();
                    });
                }
            });
        }

        // Apply all filters (demographic + county)
        function applyAllFilters() {
            if (!originalData) return;
            
            const filters = {
                dem: parseInt(document.getElementById('demSlider').value) / 100, // Convert to decimal
                rep: parseInt(document.getElementById('repSlider').value) / 100,
                white: parseInt(document.getElementById('whiteSlider').value) / 100,
                black: parseInt(document.getElementById('blackSlider').value) / 100,
                hispanic: parseInt(document.getElementById('hispanicSlider').value) / 100,
                asian: parseInt(document.getElementById('asianSlider').value) / 100
            };
            
            const filteredData = {
                ...originalData,
                features: originalData.features.filter(feature => {
                    const props = feature.properties;
                    
                    // County filter
                    const county = props.County || 'Unknown';
                    if (!selectedCounties.has(county)) {
                        return false;
                    }
                    
                    // Demographic filters
                    return (props.Dem_pct || 0) >= filters.dem &&
                           (props.Rep_pct || 0) >= filters.rep &&
                           (props.White_Vap_pct || 0) >= filters.white &&
                           (props.Black_Vap_pct || 0) >= filters.black &&
                           (props.Hispanic_Vap_pct || 0) >= filters.hispanic &&
                           (props.Asian_Vap_pct || 0) >= filters.asian;
                })
            };
            
            loadGeoJSON(filteredData);
            selectedFeatures = [];
            updateSummary();
            
            const visibleCount = filteredData.features.length;
            const totalCount = originalData.features.length;
            console.log(`Filters applied: ${visibleCount}/${totalCount} features visible`);
        }

        // Color coding - Dem_pct is already in percentage format (.60 = 60%)
        function getColor(demPct) {
            const pct = parseFloat(demPct) || 0; // No conversion needed - already in decimal
            console.log('Coloring polygon with Dem_pct:', demPct, '→', (pct * 100).toFixed(1) + '%');
            
            if (pct < 0.20) return '#8b0000';      // Dark red (< 20%)
            if (pct < 0.40) return '#dc143c';      // Medium red (20-40%)
            if (pct < 0.49) return '#ff6b6b';      // Light red (40-49%)
            if (pct < 0.60) return '#4dabf7';      // Light blue (49-60%)
            return '#1864ab';                      // Dark blue (60%+)
        }

        // Style polygons
        function style(feature) {
            const demPct = parseFloat(feature.properties.Dem_pct) || 0;
            return {
                fillColor: getColor(demPct),
                weight: 1,
                opacity: 1,
                color: 'white',
                fillOpacity: 0.7
            };
        }

        // Highlight style
        function highlightStyle(feature) {
            return {
                fillColor: getColor(feature.properties.Dem_pct),
                weight: 3,
                color: '#ffff00',
                fillOpacity: 0.9
            };
        }

        // Load GeoJSON onto map
        function loadGeoJSON(geojson) {
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            geoJsonLayer = L.geoJSON(geojson, {
                style: style,
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    const demPct = parseFloat(props.Dem_pct) || 0; // Already in decimal format
                    
                    layer.bindTooltip(`
                        <strong>County:</strong> ${props.County || 'N/A'}<br>
                        <strong>VTD:</strong> ${props.VTD || 'N/A'}<br>
                        <strong>Dem %:</strong> ${(demPct * 100).toFixed(1)}%
                    `);

                    layer.on('click', function(e) {
                        // In buffer mode, let the map handle the click for buffer selection
                        if (isBufferMode) {
                            return; // Don't handle individual polygon selection in buffer mode
                        }
                        
                        toggleFeatureSelection(feature, layer);
                        L.DomEvent.stopPropagation(e);
                    });
                }
            }).addTo(map);

            map.fitBounds(geoJsonLayer.getBounds(), {padding: [20, 20]});
        }

        // Select features in drawn area
        function selectFeaturesInDrawnArea(drawnLayer) {
            console.log('Selecting features in drawn area...');
            selectedFeatures = [];
            
            if (!geoJsonLayer) return;

            geoJsonLayer.eachLayer(function(layer) {
                const feature = layer.feature;
                if (isFeatureInDrawnArea(feature, drawnLayer)) {
                    selectedFeatures.push({feature: feature, layer: layer});
                    layer.setStyle(highlightStyle(feature));
                } else {
                    layer.setStyle(style(feature));
                }
            });
            
            console.log(`Selected ${selectedFeatures.length} features`);
            updateSummary();
        }

        // Check if feature intersects with drawn area
        function isFeatureInDrawnArea(feature, drawnLayer) {
            if (!feature.geometry || !feature.geometry.coordinates) return false;
            
            try {
                const drawnBounds = drawnLayer.getBounds();
                
                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    return coords.some(coord => {
                        return drawnBounds.contains([coord[1], coord[0]]);
                    });
                }
                return false;
            } catch (e) {
                console.error('Error in intersection check:', e);
                return false;
            }
        }

        // Toggle feature selection
        function toggleFeatureSelection(feature, layer) {
            const index = selectedFeatures.findIndex(f => f.feature === feature);
            
            if (index > -1) {
                selectedFeatures.splice(index, 1);
                layer.setStyle(style(feature));
            } else {
                selectedFeatures.push({feature: feature, layer: layer});
                layer.setStyle(highlightStyle(feature));
            }
            
            updateSummary();
        }

        // Reset highlights
        function resetHighlight() {
            if (geoJsonLayer) {
                geoJsonLayer.eachLayer(function(layer) {
                    layer.setStyle(style(layer.feature));
                });
            }
        }

        // Update summary
        function updateSummary() {
            const summaryContent = document.getElementById('summaryContent');
            
            if (selectedFeatures.length === 0) {
                summaryContent.innerHTML = '<p style="color: #666; text-align: center; font-size: 12px;">Select areas to view data</p>';
                return;
            }

            const aggregated = aggregateData(selectedFeatures.map(sf => sf.feature.properties));
            
            let html = `<div class="summary-item">
                <span class="summary-label">Selected Areas:</span>
                <span class="summary-value">${selectedFeatures.length}</span>
            </div>`;
            
            Object.entries(aggregated).forEach(([key, value]) => {
                let displayValue;
                if (key.includes('_pct') || key.includes('_Pct')) {
                    // Convert decimal percentages to display format
                    displayValue = `${(value * 100).toFixed(1)}%`;
                } else {
                    displayValue = value.toLocaleString();
                }
                
                html += `<div class="summary-item">
                    <span class="summary-label">${formatLabel(key)}:</span>
                    <span class="summary-value">${displayValue}</span>
                </div>`;
            });
            
            summaryContent.innerHTML = html;
        }

        // Aggregate data
        function aggregateData(propertiesArray) {
            if (propertiesArray.length === 0) return {};
            
            const result = {};
            const sampleProps = propertiesArray[0];
            
            Object.keys(sampleProps).forEach(key => {
                if (key === 'geometry' || key === 'GEOID' || key === 'PCTKEY') return;
                
                const values = propertiesArray.map(p => parseFloat(p[key]) || 0).filter(v => !isNaN(v));
                if (values.length === 0) return;
                
                if (key.includes('_pct') || key.includes('_Pct')) {
                    result[key] = values.reduce((sum, val) => sum + val, 0) / values.length;
                } else if (['Dem', 'Rep', 'Total'].includes(key) || key.endsWith('vap')) {
                    result[key] = values.reduce((sum, val) => sum + val, 0);
                }
            });
            
            return result;
        }

        // Format labels
        function formatLabel(key) {
            return key.replace(/_/g, ' ')
                     .replace(/pct/gi, '%')
                     .replace(/vap/gi, 'VAP')
                     .replace(/\b\w/g, l => l.toUpperCase());
        }

        // Test function to verify buffer functionality
        function testBufferTool() {
            console.log('Testing buffer tool...');
            const bufferBtn = document.getElementById('bufferBtn');
            const bufferControls = document.getElementById('bufferControls');
            
            if (bufferBtn) {
                console.log('Buffer button found, testing click...');
                // Force show buffer controls for testing
                if (bufferControls) {
                    bufferControls.style.display = 'flex';
                    console.log('Buffer controls forced visible');
                }
                
                // Test the toggle function
                console.log('Current buffer mode:', isBufferMode);
                toggleBufferMode();
                console.log('Buffer mode after toggle:', isBufferMode);
            } else {
                console.error('Buffer button not found for testing');
            }
        }
    </script>
</body>
</html>