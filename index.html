<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proposed CD 3 Data Analytics</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #007bff;
        }
        
        .main-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        
        .subtitle {
            font-size: 14px;
            color: #666;
            margin: 5px 0 0 0;
        }
        
        .loading-message {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        
        .filters {
            margin-bottom: 20px;
        }
        
        .filter-group {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .filter-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .party-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .party-filter {
            flex: 1;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .party-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .party-icon {
            width: 25px;
            height: 25px;
            margin-right: 8px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dem-icon {
            color: #0066cc;
        }
        
        .rep-icon {
            color: #cc0000;
        }
        
        .range-container {
            margin: 10px 0;
        }
        
        .range-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .range-input {
            flex: 1;
        }
        
        .range-value {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
        
        .demo-filter {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .demo-label {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .summary {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .summary h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        
        .summary-label {
            font-weight: 500;
            color: #555;
        }
        
        .summary-value {
            font-weight: bold;
            color: #333;
        }
        
        .legend {
            position: absolute;
            bottom: 60px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }
        
        .instruction {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            color: #666;
            border-left: 4px solid #007bff;
        }
        
        .credit {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #666;
            z-index: 1000;
        }
        
        .debug-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #333;
            border-left: 4px solid #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1 class="main-title">Proposed CD 3 Data Analytics</h1>
                <p class="subtitle">By Ifte Islam PhD</p>
            </div>
            
            <div class="loading-message" id="loadingMessage">
                üîÑ Loading prop3.geojson...
            </div>
            
            <div class="debug-info" id="debugInfo" style="display: none;">
                <strong>Debug Info:</strong><br>
                <span id="debugContent"></span>
            </div>
            
            <div class="instruction" id="instructionPanel" style="display: none;">
                üí° Use the drawing tools on the map or click individual polygons to select areas and view aggregated data.
            </div>
            
            <div class="filters" id="filtersPanel" style="display: none;">
                <div class="filter-group">
                    <div class="filter-title">üéØ Party Filters</div>
                    <div class="party-filters">
                        <div class="party-filter">
                            <div class="party-header">
                                <div class="party-icon dem-icon">üê¥</div>
                                <div style="font-size: 12px; font-weight: bold;">Democratic %</div>
                            </div>
                            <div class="range-container">
                                <div class="range-inputs">
                                    <input type="range" class="range-input" id="demMinRange" min="0" max="100" value="0">
                                    <span style="font-size: 10px;">to</span>
                                    <input type="range" class="range-input" id="demMaxRange" min="0" max="100" value="100">
                                </div>
                                <div class="range-value" id="demValue">Range: 0% - 100%</div>
                            </div>
                        </div>
                        <div class="party-filter">
                            <div class="party-header">
                                <div class="party-icon rep-icon">üêò</div>
                                <div style="font-size: 12px; font-weight: bold;">Republican %</div>
                            </div>
                            <div class="range-container">
                                <div class="range-inputs">
                                    <input type="range" class="range-input" id="repMinRange" min="0" max="100" value="0">
                                    <span style="font-size: 10px;">to</span>
                                    <input type="range" class="range-input" id="repMaxRange" min="0" max="100" value="100">
                                </div>
                                <div class="range-value" id="repValue">Range: 0% - 100%</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="filter-group">
                    <div class="filter-title">üë• Demographics</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="demo-filter">
                            <div class="demo-label">White %</div>
                            <div class="range-inputs">
                                <input type="range" class="range-input" id="whiteMinRange" min="0" max="100" value="0">
                                <span style="font-size: 10px;">to</span>
                                <input type="range" class="range-input" id="whiteMaxRange" min="0" max="100" value="100">
                            </div>
                            <div class="range-value" id="whiteValue">0% - 100%</div>
                        </div>
                        <div class="demo-filter">
                            <div class="demo-label">Black %</div>
                            <div class="range-inputs">
                                <input type="range" class="range-input" id="blackMinRange" min="0" max="100" value="0">
                                <span style="font-size: 10px;">to</span>
                                <input type="range" class="range-input" id="blackMaxRange" min="0" max="100" value="100">
                            </div>
                            <div class="range-value" id="blackValue">0% - 100%</div>
                        </div>
                        <div class="demo-filter">
                            <div class="demo-label">Hispanic %</div>
                            <div class="range-inputs">
                                <input type="range" class="range-input" id="hispanicMinRange" min="0" max="100" value="0">
                                <span style="font-size: 10px;">to</span>
                                <input type="range" class="range-input" id="hispanicMaxRange" min="0" max="100" value="100">
                            </div>
                            <div class="range-value" id="hispanicValue">0% - 100%</div>
                        </div>
                        <div class="demo-filter">
                            <div class="demo-label">Asian %</div>
                            <div class="range-inputs">
                                <input type="range" class="range-input" id="asianMinRange" min="0" max="100" value="0">
                                <span style="font-size: 10px;">to</span>
                                <input type="range" class="range-input" id="asianMaxRange" min="0" max="100" value="100">
                            </div>
                            <div class="range-value" id="asianValue">0% - 100%</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="summary" id="summary" style="display: none;">
                <h3>üìä Selected Area Summary</h3>
                <div id="summaryContent">
                    <p style="color: #666; text-align: center;">Select areas on the map to view aggregated data</p>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="legend" id="legend" style="display: none;">
                <h4>Democratic %</h4>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #8b0000;"></div>
                    <span>0-20%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc143c;"></div>
                    <span>20-40%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <span>40-49%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4dabf7;"></div>
                    <span>50-60%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #1864ab;"></div>
                    <span>60%+</span>
                </div>
            </div>
            <div class="credit">PrecinctSmart.com</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.min.js"></script>
    <script>
        let map, geoJsonLayer, selectedFeatures = [];
        let originalData = null;
        let dataRanges = {};
        let drawControl = null;
        let drawnItems = null;

        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Initialize drawn items layer
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Load GeoJSON automatically
            loadGeoJSONFromFile();
        }

        // Auto-load GeoJSON from same directory
        async function loadGeoJSONFromFile() {
            try {
                const response = await fetch('prop3.geojson');
                if (response.ok) {
                    const geojson = await response.json();
                    originalData = geojson;
                    
                    // Debug: Check the data structure
                    console.log('GeoJSON loaded:', geojson);
                    if (geojson.features && geojson.features.length > 0) {
                        console.log('Sample feature properties:', geojson.features[0].properties);
                        const sampleDemPct = geojson.features[0].properties.Dem_pct;
                        console.log('Sample Dem_pct value:', sampleDemPct, typeof sampleDemPct);
                        
                        // Show debug info
                        showDebugInfo(geojson);
                    }
                    
                    calculateDataRanges(geojson);
                    setupFilters();
                    loadGeoJSON(geojson);
                    setupDrawingControls();
                    showInterface();
                } else {
                    document.getElementById('loadingMessage').innerHTML = 
                        '‚ùå Could not find prop3.geojson file. Please ensure your GeoJSON file is named prop3.geojson in the same directory.';
                }
            } catch (error) {
                document.getElementById('loadingMessage').innerHTML = 
                    '‚ùå Error loading prop3.geojson: ' + error.message;
                console.error('Error loading GeoJSON:', error);
            }
        }

        // Show debug information
        function showDebugInfo(geojson) {
            const debugEl = document.getElementById('debugInfo');
            const debugContent = document.getElementById('debugContent');
            
            const totalFeatures = geojson.features.length;
            const sampleProps = geojson.features[0].properties;
            const demPctValues = geojson.features.slice(0, 5).map(f => f.properties.Dem_pct);
            
            debugContent.innerHTML = `
                Features: ${totalFeatures}<br>
                Sample Dem_pct values: ${demPctValues.join(', ')}<br>
                Available columns: ${Object.keys(sampleProps).join(', ')}
            `;
            
            debugEl.style.display = 'block';
        }

        // Calculate min/max ranges for filters
        function calculateDataRanges(geojson) {
            dataRanges = {
                dem: { min: Infinity, max: -Infinity },
                rep: { min: Infinity, max: -Infinity },
                white: { min: Infinity, max: -Infinity },
                black: { min: Infinity, max: -Infinity },
                hispanic: { min: Infinity, max: -Infinity },
                asian: { min: Infinity, max: -Infinity }
            };

            geojson.features.forEach(feature => {
                const props = feature.properties;
                
                // Parse values as numbers, handle both string and number formats
                const demPct = parseFloat(props.Dem_pct) || 0;
                const repPct = parseFloat(props.Rep_pct) || 0;
                const whitePct = parseFloat(props.White_Vap_pct) || 0;
                const blackPct = parseFloat(props.Black_Vap_pct) || 0;
                const hispanicPct = parseFloat(props.Hispanic_Vap_pct) || 0;
                const asianPct = parseFloat(props.Asian_Vap_pct) || 0;

                // Update ranges
                dataRanges.dem.min = Math.min(dataRanges.dem.min, demPct);
                dataRanges.dem.max = Math.max(dataRanges.dem.max, demPct);
                dataRanges.rep.min = Math.min(dataRanges.rep.min, repPct);
                dataRanges.rep.max = Math.max(dataRanges.rep.max, repPct);
                dataRanges.white.min = Math.min(dataRanges.white.min, whitePct);
                dataRanges.white.max = Math.max(dataRanges.white.max, whitePct);
                dataRanges.black.min = Math.min(dataRanges.black.min, blackPct);
                dataRanges.black.max = Math.max(dataRanges.black.max, blackPct);
                dataRanges.hispanic.min = Math.min(dataRanges.hispanic.min, hispanicPct);
                dataRanges.hispanic.max = Math.max(dataRanges.hispanic.max, hispanicPct);
                dataRanges.asian.min = Math.min(dataRanges.asian.min, asianPct);
                dataRanges.asian.max = Math.max(dataRanges.asian.max, asianPct);
            });

            console.log('Data ranges calculated:', dataRanges);
        }

        // Setup drawing controls properly
        function setupDrawingControls() {
            // Create draw control
            drawControl = new L.Control.Draw({
                position: 'topleft',
                draw: {
                    polyline: false,
                    polygon: {
                        allowIntersection: false,
                        drawError: {
                            color: '#e1e100',
                            message: '<strong>Oh snap!<strong> you can\'t draw that!'
                        },
                        shapeOptions: {
                            color: '#bada55'
                        }
                    },
                    circle: {
                        shapeOptions: {
                            color: '#662d91'
                        }
                    },
                    rectangle: {
                        shapeOptions: {
                            color: '#662d91'
                        }
                    },
                    marker: false,
                    circlemarker: false
                },
                edit: {
                    featureGroup: drawnItems,
                    remove: true
                }
            });

            map.addControl(drawControl);

            // Handle draw events
            map.on(L.Draw.Event.CREATED, function(e) {
                const type = e.layerType;
                const layer = e.layer;
                
                console.log('Draw created:', type, layer);
                drawnItems.addLayer(layer);
                selectFeaturesInDrawnArea(layer);
            });

            map.on(L.Draw.Event.DELETED, function(e) {
                console.log('Draw deleted');
                selectedFeatures = [];
                updateSummary();
                resetHighlight();
            });

            map.on(L.Draw.Event.EDITED, function(e) {
                console.log('Draw edited');
                const layers = e.layers;
                layers.eachLayer(function(layer) {
                    selectFeaturesInDrawnArea(layer);
                });
            });
        }

        // Show interface after loading
        function showInterface() {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('instructionPanel').style.display = 'block';
            document.getElementById('filtersPanel').style.display = 'block';
            document.getElementById('summary').style.display = 'block';
            document.getElementById('legend').style.display = 'block';
        }

        // Color coding function based on Dem_pct - more distinct colors
        function getColor(demPct) {
            const pct = parseFloat(demPct) || 0;
            console.log('Getting color for Dem_pct:', pct);
            
            if (pct < 20) return '#8b0000';      // Dark red
            if (pct < 40) return '#dc143c';      // Medium red  
            if (pct < 49) return '#ff6b6b';      // Light red
            if (pct < 60) return '#4dabf7';      // Light blue
            return '#1864ab';                    // Dark blue
        }

        // Style function for polygons
        function style(feature) {
            const demPct = parseFloat(feature.properties.Dem_pct) || 0;
            const color = getColor(demPct);
            console.log('Styling feature with Dem_pct:', demPct, 'Color:', color);
            
            return {
                fillColor: color,
                weight: 1,
                opacity: 1,
                color: 'white',
                fillOpacity: 0.7
            };
        }

        // Highlight style
        function highlightStyle(feature) {
            const demPct = parseFloat(feature.properties.Dem_pct) || 0;
            return {
                fillColor: getColor(demPct),
                weight: 3,
                color: '#ffff00',
                fillOpacity: 0.9
            };
        }

        // Load GeoJSON onto map
        function loadGeoJSON(geojson) {
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            geoJsonLayer = L.geoJSON(geojson, {
                style: style,
                onEachFeature: function(feature, layer) {
                    // Hover tooltip
                    const props = feature.properties;
                    const demPct = parseFloat(props.Dem_pct) || 0;
                    const tooltipContent = `
                        <strong>County:</strong> ${props.County || 'N/A'}<br>
                        <strong>VTD:</strong> ${props.VTD || 'N/A'}<br>
                        <strong>Dem %:</strong> ${demPct.toFixed(1)}%
                    `;
                    layer.bindTooltip(tooltipContent);

                    // Click to select individual polygons
                    layer.on('click', function(e) {
                        console.log('Polygon clicked:', feature.properties);
                        toggleFeatureSelection(feature, layer);
                        L.DomEvent.stopPropagation(e);
                    });
                }
            }).addTo(map);

            map.fitBounds(geoJsonLayer.getBounds());
        }

        // Toggle individual feature selection
        function toggleFeatureSelection(feature, layer) {
            const index = selectedFeatures.findIndex(f => f.feature === feature);
            
            if (index > -1) {
                selectedFeatures.splice(index, 1);
                layer.setStyle(style(feature));
            } else {
                selectedFeatures.push({feature: feature, layer: layer});
                layer.setStyle(highlightStyle(feature));
            }
            
            updateSummary();
        }

        // Select features within drawn area
        function selectFeaturesInDrawnArea(drawnLayer) {
            console.log('Selecting features in drawn area:', drawnLayer);
            selectedFeatures = [];
            
            if (!geoJsonLayer) {
                console.log('No geoJsonLayer available');
                return;
            }

            geoJsonLayer.eachLayer(function(layer) {
                const feature = layer.feature;
                
                try {
                    if (isFeatureInDrawnArea(feature, drawnLayer)) {
                        selectedFeatures.push({feature: feature, layer: layer});
                        layer.setStyle(highlightStyle(feature));
                    } else {
                        layer.setStyle(style(feature));
                    }
                } catch (e) {
                    console.error('Error checking feature intersection:', e);
                }
            });
            
            console.log('Selected features:', selectedFeatures.length);
            updateSummary();
        }

        // Check if feature intersects with drawn area
        function isFeatureInDrawnArea(feature, drawnLayer) {
            if (!feature.geometry || !feature.geometry.coordinates) return false;
            
            try {
                // Simple bounds-based intersection check
                const drawnBounds = drawnLayer.getBounds();
                
                if (feature.geometry.type === 'Polygon') {
                    const coords = feature.geometry.coordinates[0];
                    return coords.some(coord => {
                        const lat = coord[1];
                        const lng = coord[0];
                        return drawnBounds.contains([lat, lng]);
                    });
                }
                
                return false;
            } catch (e) {
                console.error('Error in intersection check:', e);
                return false;
            }
        }

        // Reset highlight
        function resetHighlight() {
            if (geoJsonLayer) {
                geoJsonLayer.eachLayer(function(layer) {
                    layer.setStyle(style(layer.feature));
                });
            }
        }

        // Update summary with aggregated data
        function updateSummary() {
            const summaryContent = document.getElementById('summaryContent');
            
            if (selectedFeatures.length === 0) {
                summaryContent.innerHTML = '<p style="color: #666; text-align: center;">Select areas on the map to view aggregated data</p>';
                return;
            }

            const aggregated = aggregateData(selectedFeatures.map(sf => sf.feature.properties));
            
            let html = `<div class="summary-item">
                <span class="summary-label">Selected Areas:</span>
                <span class="summary-value">${selectedFeatures.length}</span>
            </div>`;
            
            Object.entries(aggregated).forEach(([key, value]) => {
                const displayValue = key.includes('_pct') || key.includes('_Pct') ? 
                    `${value.toFixed(1)}%` : 
                    value.toLocaleString();
                
                html += `<div class="summary-item">
                    <span class="summary-label">${formatLabel(key)}:</span>
                    <span class="summary-value">${displayValue}</span>
                </div>`;
            });
            
            summaryContent.innerHTML = html;
        }

        // Aggregate data according to rules
        function aggregateData(propertiesArray) {
            if (propertiesArray.length === 0) return {};
            
            const result = {};
            const sampleProps = propertiesArray[0];
            
            Object.keys(sampleProps).forEach(key => {
                if (key === 'geometry' || key === 'GEOID' || key === 'PCTKEY') return;
                
                const values = propertiesArray.map(p => parseFloat(p[key]) || 0).filter(v => !isNaN(v));
                if (values.length === 0) return;
                
                if (key.includes('_pct') || key.includes('_Pct')) {
                    // Average for percentage columns
                    result[key] = values.reduce((sum, val) => sum + val, 0) / values.length;
                } else if (['Dem', 'Rep', 'Total'].includes(key) || key.endsWith('vap')) {
                    // Sum for vote counts and VAP columns
                    result[key] = values.reduce((sum, val) => sum + val, 0);
                }
            });
            
            return result;
        }

        // Format label for display
        function formatLabel(key) {
            return key.replace(/_/g, ' ')
                     .replace(/pct/gi, '%')
                     .replace(/vap/gi, 'VAP')
                     .replace(/\b\w/g, l => l.toUpperCase());
        }

        // Setup filters with continuous ranges
        function setupFilters() {
            const filterConfigs = [
                { id: 'dem', label: 'Democratic', key: 'Dem_pct' },
                { id: 'rep', label: 'Republican', key: 'Rep_pct' },
                { id: 'white', label: 'White', key: 'White_Vap_pct' },
                { id: 'black', label: 'Black', key: 'Black_Vap_pct' },
                { id: 'hispanic', label: 'Hispanic', key: 'Hispanic_Vap_pct' },
                { id: 'asian', label: 'Asian', key: 'Asian_Vap_pct' }
            ];

            filterConfigs.forEach(config => {
                const minRange = document.getElementById(config.id + 'MinRange');
                const maxRange = document.getElementById(config.id + 'MaxRange');
                const value = document.getElementById(config.id + 'Value');
                const dataRange = dataRanges[config.id];
                
                if (minRange && maxRange && dataRange && isFinite(dataRange.min) && isFinite(dataRange.max)) {
                    const min = Math.floor(dataRange.min);
                    const max = Math.ceil(dataRange.max);
                    
                    minRange.min = min;
                    minRange.max = max;
                    minRange.value = min;
                    
                    maxRange.min = min;
                    maxRange.max = max;
                    maxRange.value = max;
                    
                    const updateValue = () => {
                        const minVal = parseInt(minRange.value);
                        const maxVal = parseInt(maxRange.value);
                        value.textContent = `${minVal}% - ${maxVal}%`;
                        applyFilters();
                    };
                    
                    minRange.addEventListener('input', updateValue);
                    maxRange.addEventListener('input', updateValue);
                    
                    updateValue(); // Initial display
                }
            });
        }

        // Apply filters to map with range filtering
        function applyFilters() {
            if (!originalData) return;
            
            const filters = {
                dem: { 
                    min: parseFloat(document.getElementById('demMinRange').value),
                    max: parseFloat(document.getElementById('demMaxRange').value)
                },
                rep: { 
                    min: parseFloat(document.getElementById('repMinRange').value),
                    max: parseFloat(document.getElementById('repMaxRange').value)
                },
                white: { 
                    min: parseFloat(document.getElementById('whiteMinRange').value),
                    max: parseFloat(document.getElementById('whiteMaxRange').value)
                },
                black: { 
                    min: parseFloat(document.getElementById('blackMinRange').value),
                    max: parseFloat(document.getElementById('blackMaxRange').value)
                },
                hispanic: { 
                    min: parseFloat(document.getElementById('hispanicMinRange').value),
                    max: parseFloat(document.getElementById('hispanicMaxRange').value)
                },
                asian: { 
                    min: parseFloat(document.getElementById('asianMinRange').value),
                    max: parseFloat(document.getElementById('asianMaxRange').value)
                }
            };
            
            const filteredData = {
                ...originalData,
                features: originalData.features.filter(feature => {
                    const props = feature.properties;
                    const demPct = parseFloat(props.Dem_pct) || 0;
                    const repPct = parseFloat(props.Rep_pct) || 0;
                    const whitePct = parseFloat(props.White_Vap_pct) || 0;
                    const blackPct = parseFloat(props.Black_Vap_pct) || 0;
                    const hispanicPct = parseFloat(props.Hispanic_Vap_pct) || 0;
                    const asianPct = parseFloat(props.Asian_Vap_pct) || 0;
                    
                    return demPct >= filters.dem.min && demPct <= filters.dem.max &&
                           repPct >= filters.rep.min && repPct <= filters.rep.max &&
                           whitePct >= filters.white.min && whitePct <= filters.white.max &&
                           blackPct >= filters.black.min && blackPct <= filters.black.max &&
                           hispanicPct >= filters.hispanic.min && hispanicPct <= filters.hispanic.max &&
                           asianPct >= filters.asian.min && asianPct <= filters.asian.max;
                })
            };
            
            loadGeoJSON(filteredData);
            selectedFeatures = [];
            updateSummary();
        }

        // Initialize everything
        initMap();
    </script>
</body>
</html>